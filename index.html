<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Baseline History Tree</title>

<style>
body { font-family: Arial, sans-serif; margin:0; padding:0; }
header, footer { font-size: 14px; padding: 4px 8px; background: #f0f0f0; }

.grid-line { stroke: #e0e0e0; stroke-width: 1px; }
.coord { font-size: 10px; fill: #555; }

.node rect {
    fill: #fff;
    stroke: #333;
    stroke-width: 1.5px;
}

.node.mainline rect {
    fill: #d8f2d8;
}

.node text {
    font-size: 10px;
    fill: #000;
    text-anchor: middle;
    pointer-events: none;
}

.node text.cfg {
    font-weight: bold;
}

.link {
    fill: none;
    stroke: #666;
    stroke-width: 2px;
}
</style>
</head>

<body>
<header>Baseline History Tree</header>
<svg id="grid"></svg>
<footer>Mouse wheel = zoom, drag = pan</footer>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const headerH = 28;
const footerH = 20;
const width = window.innerWidth;
const height = window.innerHeight - headerH - footerH;

const svg = d3.select("#grid")
  .attr("width", width)
  .attr("height", height);

const gZoom = svg.append("g");

svg.call(
  d3.zoom()
    .scaleExtent([0.5, 4])
    .on("zoom", e => gZoom.attr("transform", e.transform))
);

const cellW = 200;
const cellH = 60;
const trunkX = width / 2;
const offsetY = height - cellH;

d3.json("baseline_history.json").then(data => {

    const nodes = data.nodes;
    const links = data.links;
    const nodeById = new Map(nodes.map(n => [n.id, n]));

    // --- build children map ---
    const children = new Map();
    nodes.forEach(n => children.set(n.id, []));
    links.forEach(l => children.get(l.source).push(nodeById.get(l.target)));

    // --- classify children ---
    nodes.forEach(n => {
        n.mainlineChild = null;
        n.sideChildren = [];
        children.get(n.id).forEach(c => {
            c.mainline ? n.mainlineChild = c : n.sideChildren.push(c);
        });
    });

    // --- extract mainline ---
    const mainline = [];
    let cur = nodes.find(n => n.mainline && n.predecessors.length === 0);
    while (cur) {
        mainline.push(cur);
        cur = cur.mainlineChild;
    }

    function branchOrder(a, b) {
        if (a.root_distance !== b.root_distance)
            return a.root_distance - b.root_distance;
        return new Date(a.baselines[0].creation_date) -
               new Date(b.baselines[0].creation_date);
    }

    // --- side branch layout ---
    function layoutSideBranch(node, depth, startLane) {
        const x = -depth;

        node.gridX = x;
        node.gridY = startLane;
        node.x = trunkX + x * cellW;
        node.y = offsetY - startLane * cellH;

        let maxLane = startLane;
        const sides = node.sideChildren.slice().sort(branchOrder);

        if (sides.length > 0) {
            // continuation
            maxLane = Math.max(
                maxLane,
                layoutSideBranch(sides[0], depth + 1, startLane)
            );

            // forks
            for (let i = 1; i < sides.length; i++) {
                maxLane = Math.max(
                    maxLane,
                    layoutSideBranch(sides[i], depth + 1, maxLane + 1)
                );
            }
        }

        return maxLane;
    }

    // --- mainline-driven layout ---
    let currentLane = 0;

    mainline.forEach(m => {
        // place mainline node
        m.gridX = 0;
        m.gridY = currentLane;
        m.x = trunkX;
        m.y = offsetY - currentLane * cellH;

        let maxLane = currentLane;
        let nextSideLane = currentLane;

        // render side branches sequentially
        m.sideChildren
            .slice()
            .sort(branchOrder)
            .forEach(sc => {
                const usedLane = layoutSideBranch(sc, 1, nextSideLane);
                maxLane = Math.max(maxLane, usedLane);
                nextSideLane = usedLane + 1;
            });

        // advance mainline
        currentLane = maxLane + 1;
    });

    // --- DEBUG OUTPUT ---
    console.group("Baseline layout debug");
    nodes.forEach(n => {
        const created = n.baselines
            .map(b => b.creation_date)
            .sort()[0];

        console.log(
            `cfg=${n.id}`,
            `names=${n.baselines.map(b => b.name).join(", ")}`,
            `mainline=${n.mainline}`,
            `rootDist=${n.root_distance}`,
            `created=${created}`,
            `grid=(${n.gridX}, ${n.gridY})`
        );
    });
    console.groupEnd();

    // --- draw links ---
    gZoom.selectAll(".link")
        .data(links)
        .enter()
        .append("path")
        .attr("class","link")
        .attr("d", d => {
            const s = nodeById.get(d.source);
            const t = nodeById.get(d.target);
            return `M${s.x},${s.y} L${t.x},${t.y}`;
        });

    // --- draw nodes ---
    const g = gZoom.selectAll(".node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", d => `node${d.mainline ? " mainline" : ""}`)
        .attr("transform", d => `translate(${d.x},${d.y})`);

    const boxW = 120;
    const pad = 6;
    const lineH = 12;

    g.each(function(d){
        const g = d3.select(this);
        const lines = [d.id, ...d.baselines.map(b => b.name)];
        const h = pad*2 + lines.length * lineH;

        g.append("rect")
            .attr("x", -boxW/2)
            .attr("y", -h/2)
            .attr("width", boxW)
            .attr("height", h)
            .attr("rx", 4);

        lines.forEach((t,i) => {
            g.append("text")
                .attr("class", i === 0 ? "cfg" : null)
                .attr("y", -h/2 + pad + (i+1)*lineH - 4)
                .text(t);
        });
    });
});
</script>
</body>
</html>
