<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Baseline History Tree</title>

<style>
body { font-family: Arial, sans-serif; margin:0; padding:0; }
header, footer { font-size: 14px; padding: 4px 8px; background: #f0f0f0; }

.grid-line { stroke: #e0e0e0; stroke-width: 1px; }
.coord { font-size: 10px; fill: #555; }

.node rect {
    fill: #fff;
    stroke: #333;
    stroke-width: 1.5px;
}

.node.mainline rect {
    fill: #d8f2d8;
}

.node text {
    font-size: 10px;
    fill: #000;
    text-anchor: middle;
    pointer-events: none;
}

.node text.cfg {
    font-weight: bold;
}

.link {
    fill: none;
    stroke: #666;
    stroke-width: 2px;
}
</style>
</head>

<body>
<header>Baseline History Tree</header>
<svg id="grid"></svg>
<footer>Mouse wheel = zoom, drag = pan</footer>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const headerH = 28;
const footerH = 20;
const width = window.innerWidth;
const height = window.innerHeight - headerH - footerH;

const svg = d3.select("#grid")
  .attr("width", width)
  .attr("height", height);

const gZoom = svg.append("g");

svg.call(
  d3.zoom()
    .scaleExtent([0.5, 4])
    .on("zoom", e => gZoom.attr("transform", e.transform))
);

// === GRID ===
const cellW = 200;
const cellH = 60;
const trunkX = width / 2;
const offsetY = height - cellH;

for (let y = -1; y <= 50; y++) {
    const py = offsetY - y * cellH;
    gZoom.append("line")
        .attr("class","grid-line")
        .attr("x1", trunkX - 10 * cellW)
        .attr("y1", py)
        .attr("x2", trunkX + 10 * cellW)
        .attr("y2", py);

    gZoom.append("text")
        .attr("class","coord")
        .attr("x", trunkX - 10 * cellW - 10)
        .attr("y", py + 4)
        .text(`y=${y}`);
}

for (let x = -10; x <= 10; x++) {
    const px = trunkX + x * cellW;
    gZoom.append("line")
        .attr("class","grid-line")
        .attr("x1", px)
        .attr("y1", offsetY + cellH)
        .attr("x2", px)
        .attr("y2", offsetY - 50 * cellH);

    gZoom.append("text")
        .attr("class","coord")
        .attr("x", px)
        .attr("y", offsetY + 14)
        .text(`x=${x}`);
}

// === DATA ===
d3.json("baseline_history.json").then(data => {

    const nodes = data.nodes;
    const links = data.links;
    const nodeById = new Map(nodes.map(n => [n.id, n]));

    // Build children map
    const children = new Map();
    nodes.forEach(n => children.set(n.id, []));
    links.forEach(l => children.get(l.source).push(nodeById.get(l.target)));

    // Split children into mainline and side branches
    nodes.forEach(n => {
        n.mainlineChild = null;
        n.sideChildren = [];
        (children.get(n.id) || []).forEach(c => {
            c.mainline ? n.mainlineChild = c : n.sideChildren.push(c);
        });
    });

    // === SIDE BRANCH ORDERING ===
    function branchOrder(a, b) {
        if (a.root_distance !== b.root_distance) {
            return a.root_distance - b.root_distance;
        }
        const da = new Date(a.baselines[0].creation_date);
        const db = new Date(b.baselines[0].creation_date);
        if (da - db !== 0) return da - db;
        return a.id.localeCompare(b.id);
    }

    // === LAYOUT ===
    function layoutNode(node, x, lane, dir) {
        node.gridX = x;
        node.gridY = lane;
        node.x = trunkX + x * cellW;
        node.y = offsetY - lane * cellH;

        let nextLane = lane;

        const main = node.mainlineChild;
        const sides = node.sideChildren.slice();

        // ---- SIDE BRANCHES ----
        if (sides.length > 0) {
            sides.sort(branchOrder);

            const dx = dir || -1;

            // one side branch stays on same lane
            const stay = sides.shift();
            layoutNode(stay, x + dx, lane, dx);

            // remaining side branches fork
            sides.forEach(sc => {
                nextLane += 1;
                layoutNode(sc, x + dx, nextLane, dx);
            });
        }

        // ---- MAINLINE ----
        if (main) {
            nextLane += 1;
            return layoutNode(main, x, nextLane, dir);
        }

        return nextLane;
    }

    const root = nodes.find(n => n.mainline && n.predecessors.length === 0);
    layoutNode(root, 0, 0, 1);

    // === DRAW LINKS ===
    gZoom.selectAll(".link")
        .data(links)
        .enter()
        .append("path")
        .attr("class","link")
        .attr("d", d => {
            const s = nodeById.get(d.source);
            const t = nodeById.get(d.target);
            return `M${s.x},${s.y} L${t.x},${t.y}`;
        });

    // === DRAW NODES ===
    const g = gZoom.selectAll(".node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", d => `node${d.mainline ? " mainline" : ""}`)
        .attr("transform", d => `translate(${d.x},${d.y})`);

    const boxW = 120;
    const pad = 6;
    const lineH = 12;

    g.each(function(d){
        const g = d3.select(this);
        const lines = [d.id, ...d.baselines.map(b => b.name)];
        const h = pad*2 + lines.length * lineH;

        g.append("rect")
            .attr("x", -boxW/2)
            .attr("y", -h/2)
            .attr("width", boxW)
            .attr("height", h)
            .attr("rx", 4);

        lines.forEach((t,i) => {
            g.append("text")
                .attr("class", i === 0 ? "cfg" : null)
                .attr("y", -h/2 + pad + (i+1)*lineH - 4)
                .text(t);
        });
    });
});
</script>
</body>
</html>
