<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Baseline Grid</title>
<style>
body { font-family: Arial, sans-serif; margin:0; padding:0; }
header, footer { font-size: 14px; padding: 4px 8px; background: #f0f0f0; }

.grid-line { stroke: #e0e0e0; stroke-width: 1px; }
.coord { font-size: 10px; fill: #555; }

.node rect {
    fill: #ffffff;
    stroke: #333;
    stroke-width: 1.5px;
}

.node.mainline rect {
    fill: #d8f2d8; /* light green for mainline */
}

.node text {
    font-size: 10px;
    fill: #000;
    text-anchor: middle;
    pointer-events: none;
}

.node text.cfg {
    font-weight: bold;
}

.link {
    fill: none;
    stroke: #666;
    stroke-width: 2px;
}
</style>
</head>

<body>
<header>Grid Visualization</header>
<svg id="grid"></svg>
<footer>Use mouse wheel to zoom and drag to pan</footer>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const headerH = 28;
const footerH = 20;
const width = window.innerWidth;
const height = window.innerHeight - headerH - footerH;

const svg = d3.select("#grid")
  .attr("width", width)
  .attr("height", height);

const gZoom = svg.append("g");

// Zoom
const zoom = d3.zoom()
  .scaleExtent([0.5, 4])
  .on("zoom", e => gZoom.attr("transform", e.transform));

svg.call(zoom);

// === GRID SETUP ===
const cellW = 200;
const cellH = 60;
const trunkX = width / 2;
const minGX = -10;
const maxGX = 10;
const minGY = -1;
const maxGY = 100;

const bottomOffsetRows = 1;
const offsetY = height - bottomOffsetRows * cellH;

// Horizontal grid
for (let gy = minGY; gy <= maxGY; gy++) {
    const yPix = offsetY - gy * cellH;

    gZoom.append("line")
        .attr("class", "grid-line")
        .attr("x1", trunkX + minGX * cellW)
        .attr("y1", yPix)
        .attr("x2", trunkX + maxGX * cellW)
        .attr("y2", yPix);

    gZoom.append("text")
        .attr("class", "coord")
        .attr("x", trunkX + minGX * cellW - 10)
        .attr("y", yPix + 4)
        .text(`y=${gy}`);
}

// Vertical grid
for (let gx = minGX; gx <= maxGX; gx++) {
    const xPix = trunkX + gx * cellW;

    gZoom.append("line")
        .attr("class", "grid-line")
        .attr("x1", xPix)
        .attr("y1", offsetY - minGY * cellH)
        .attr("x2", xPix)
        .attr("y2", offsetY - maxGY * cellH);

    gZoom.append("text")
        .attr("class", "coord")
        .attr("x", xPix)
        .attr("y", offsetY + 12)
        .text(`x=${gx}`);
}

// === LOAD DATA ===
d3.json("baseline_history.json").then(data => {

    const nodes = data.nodes;
    const links = data.links;
    const nodeById = new Map(nodes.map(n => [n.id, n]));

    // ---- MAINLINE ----
    const mainline = nodes
        .filter(n => n.mainline)
        .sort((a,b) => a.root_distance - b.root_distance);

    mainline.forEach(n => {
        n.gridX = 0;
        n.gridY = n.root_distance;
        n.x = trunkX;
        n.y = offsetY - n.gridY * cellH;
    });

    // ---- SIDE BRANCHES ----
    let leftCount = 0;
    let rightCount = 0;
    const branchDir = new Map();
    const branchDepth = new Map();

    nodes
      .filter(n => !n.mainline)
      .sort((a,b) => a.root_distance - b.root_distance)
      .forEach(n => {

        const preds = n.predecessors.map(id => nodeById.get(id));
        const trunkPred = preds.find(p => p.mainline);

        if (trunkPred) {
            const dir = (leftCount <= rightCount) ? -1 : +1;
            branchDir.set(n.id, dir);
            branchDepth.set(n.id, 1);
            if (dir < 0) leftCount++; else rightCount++;

            n.gridX = dir;
            n.gridY = trunkPred.gridY;
        } else if (preds.length > 0) {
            const p = preds[0];
            const dir = branchDir.get(p.id);
            const depth = branchDepth.get(p.id) + 1;

            branchDir.set(n.id, dir);
            branchDepth.set(n.id, depth);

            n.gridX = dir * depth;
            n.gridY = p.gridY;
        }

        n.x = trunkX + n.gridX * cellW;
        n.y = offsetY - n.gridY * cellH;
    });

    // ---- LINKS ----
    gZoom.selectAll(".link")
        .data(links)
        .enter()
        .append("path")
        .attr("class", "link")
        .attr("d", d => {
            const s = nodeById.get(d.source);
            const t = nodeById.get(d.target);
            return `M${s.x},${s.y} L${t.x},${t.y}`;
        });

    // ---- NODES ----
    const nodeG = gZoom.selectAll(".node")
        .data(nodes)
        .enter()
        .append("g")
        .attr("class", d => `node${d.mainline ? " mainline" : ""}`)
        .attr("transform", d => `translate(${d.x},${d.y})`);

    const padding = 6;
    const lineH = 12;
    const boxW = 120;

    nodeG.each(function(d) {
        const g = d3.select(this);
        const lines = [d.id, ...d.baselines.map(b => b.name)];
        const boxH = padding*2 + lines.length * lineH;

        g.append("rect")
            .attr("x", -boxW/2)
            .attr("y", -boxH/2)
            .attr("width", boxW)
            .attr("height", boxH)
            .attr("rx", 4)
            .attr("ry", 4);

        lines.forEach((txt, i) => {
            g.append("text")
                .attr("class", i === 0 ? "cfg" : null)
                .attr("y", -boxH/2 + padding + (i+1)*lineH - 4)
                .text(txt);
        });
    });
});
</script>
</body>
</html>
