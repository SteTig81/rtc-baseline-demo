<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>RTC Baseline History</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  overflow: hidden;
}
svg {
  width: 100vw;
  height: 100vh;
}
circle {
  stroke: #333;
  stroke-width: 1.5px;
}
text {
  font-family: sans-serif;
  font-size: 12px;
}
</style>
</head>
<body>
<svg></svg>

<script>
fetch("baseline_history.json").then(r => r.json()).then(data => {

  const svg = d3.select("svg");
  const g = svg.append("g");

  // Zoom & pan
  svg.call(d3.zoom().on("zoom", (event) => g.attr("transform", event.transform)));

  const nodeMap = new Map(data.nodes.map(n => [n.id, n]));

  // --- Compute depth (longest path from root)
  function depth(n) {
    if (n._depth !== undefined) return n._depth;
    if (!n.predecessors || n.predecessors.length === 0) {
      n._depth = 0;
    } else {
      n._depth = 1 + Math.max(...n.predecessors.map(p => depth(nodeMap.get(p))));
    }
    return n._depth;
  }
  data.nodes.forEach(depth);

  // --- Assign lanes
  let leftCounter = -1;
  let rightCounter = 1;
  data.nodes.forEach(n => {
    if (n.mainline) {
      n.lane = 0;
    } else if (n.predecessors.some(p => nodeMap.get(p).mainline)) {
      // Branch from mainline: alternate left/right
      n.lane = Math.abs(leftCounter) <= rightCounter ? leftCounter-- : rightCounter++;
    } else {
      // Long-running or merge branches, push to right
      n.lane = rightCounter++;
    }
  });

  const width = window.innerWidth;
  const height = window.innerHeight;

  const xScale = d3.scaleLinear()
    .domain([d3.min(data.nodes, d => d.lane), d3.max(data.nodes, d => d.lane)])
    .range([150, width - 150]);

  const maxDepth = d3.max(data.nodes, d => d._depth);
  const yScale = d3.scaleLinear()
    .domain([0, maxDepth])
    .range([height - 100, 100]); // bottom-up

  // --- Define arrowhead
  svg.append("defs").append("marker")
    .attr("id", "arrowhead")
    .attr("markerWidth", 10)
    .attr("markerHeight", 7)
    .attr("refX", 10)
    .attr("refY", 3.5)
    .attr("orient", "auto")
    .attr("markerUnits", "strokeWidth")
    .append("polygon")
    .attr("points", "0 0, 10 3.5, 0 7")
    .attr("fill", "#555");

  // --- Draw edges as smooth Bezier curves
  g.selectAll("path.link")
    .data(data.links)
    .enter()
    .append("path")
    .attr("d", d => {
      const s = nodeMap.get(d.source);
      const t = nodeMap.get(d.target);
      const x1 = xScale(s.lane);
      const y1 = yScale(s._depth);
      const x2 = xScale(t.lane);
      const y2 = yScale(t._depth);
      const cx1 = x1;
      const cy1 = (y1 + y2) / 2;
      const cx2 = x2;
      const cy2 = (y1 + y2) / 2;
      return `M${x1},${y1} C${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`;
    })
    .attr("fill", "none")
    .attr("stroke", "#555")
    .attr("stroke-width", 2)
    .attr("marker-end", "url(#arrowhead)");

  // --- Draw nodes
  const node = g.selectAll("g.node")
    .data(data.nodes)
    .enter()
    .append("g")
    .attr("class", "node")
    .attr("transform", d =>
      `translate(${xScale(d.lane)}, ${yScale(d._depth)})`
    );

  node.append("circle")
    .attr("r", d => 6 + Math.sqrt(d.cs_count) * 2)
    .attr("fill", d => d.mainline ? "orange" : "steelblue");

  // Labels: all baseline names per node
  node.append("text")
    .attr("dx", 12)
    .attr("dy", 4)
    .text(d => d.baselines.map(b => b.name).join(", "));

});
</script>
</body>
</html>
